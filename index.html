<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LANDORIX • Subdivider</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body { background:#fff; overflow:hidden; font-family:'Helvetica Neue',Helvetica,Arial,sans-serif; perspective:1500px; }
    #input-card {
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      background:rgba(255,255,255,0.92); backdrop-filter:blur(20px);
      padding:50px 60px; border-radius:28px; box-shadow:0 30px 80px rgba(0,0,0,0.12);
      width:420px; text-align:center; z-index:100; transition:all 0.6s cubic-bezier(0.16,1,0.3,1);
    }
    h1 { font-size:42px; font-weight:900; letter-spacing:-1px; margin-bottom:30px; color:#000; }
    select, input, button {
      width:100%; padding:18px 20px; margin:12px 0; border:none; border-radius:16px;
      font-size:18px; outline:none; transition:all 0.3s;
    }
    select, input { background:rgba(0,0,0,0.04); color:#000; }
    select:focus, input:focus { background:rgba(0,0,0,0.08); }
    button {
      background:#000; color:#fff; font-weight:700; cursor:pointer;
      box-shadow:0 10px 30px rgba(0,0,0,0.2);
    }
    button:hover { transform:translateY(-3px); box-shadow:0 20px 40px rgba(0,0,0,0.3); }
    #scene { position:absolute; inset:0; opacity:0; transition:opacity 1s; }
    #scene.active { opacity:1; }
    canvas { display:block; }
    #info {
      position:absolute; bottom:40px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,0.75); color:#0f0; padding:16px 40px; border-radius:50px;
      font-size:28px; font-weight:900; letter-spacing:1px; backdrop-filter:blur(10px);
    }
    #reset-area { position:absolute; inset:0; cursor:pointer; }
  </style>
</head>
<body>

  <!-- INPUT CARD -->
  <div id="input-card">
    <h1>SUBDIVIDER</h1>
    <select id="zone">
      <option value="" disabled selected>Select Zoning</option>
      <option value="CR-1">CR-1 • 20,000 sq ft (80 ft min width)</option>
      <option value="CR-1A">CR-1A • 1 acre (100 ft min width)</option>
      <option value="GR">GR • 1.25 acres (100 ft min width)</option>
      <option value="SH">SH • 2 acres (100 ft min width)</option>
      <option value="SR">SR • 3.3 acres (no min width)</option>
    </select>
    <input type="number" id="width" placeholder="Parcel Width (feet)" min="1" />
    <input type="number" id="depth" placeholder="Parcel Depth (feet)" min="1" />
    <button onclick="subdivide()">SUBDIVIDE</button>
  </div>

  <!-- 3D SCENE -->
  <div id="scene"></div>
  <div id="info"></div>
  <div id="reset-area" onclick="reset()"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    const zones = {
      "CR-1":  { area: 20000, width: 80 },
      "CR-1A": { area: 43560, width: 100 },
      "GR":    { area: 54450, width: 100 },
      "SH":    { area: 87120, width: 100 },
      "SR":    { area: 143748, width: null }
    };

    let scene, camera, renderer, controls, parcelGroup;

    function init3D() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);
      camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 10000);
      camera.position.set(800, 600, 800);
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(innerWidth, innerHeight);
      document.getElementById('scene').appendChild(renderer.domElement);
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enablePan = false;
      controls.minDistance = 300;
      controls.maxDistance = 2000;
      controls.maxPolarAngle = Math.PI / 2.2;

      const light = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(light);
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(500, 1000, 500);
      scene.add(dirLight);

      parcelGroup = new THREE.Group();
      scene.add(parcelGroup);

      window.addEventListener('resize', () => {
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function subdivide() {
      const zone = document.getElementById('zone').value;
      const width = parseFloat(document.getElementById('width').value);
      const depth = parseFloat(document.getElementById('depth').value);
      if (!zone || !width || !depth) return alert("Fill everything");

      document.getElementById('input-card').style.opacity = '0';
      document.getElementById('input-card').style.transform = 'translate(-50%,-60%) scale(0.8)';
      setTimeout(() => {
        document.getElementById('input-card').style.display = 'none';
        document.getElementById('scene').classList.add('active');
        init3D();
        createSubdivision(width, depth, zones[zone]);
      }, 600);
    }

    function createSubdivision(w, d, rule) {
      parcelGroup.clear();

      // Try both orientations
      const opt1 = calculateLots(w, d, rule);
      const opt2 = calculateLots(d, w, rule);
      const best = opt1.lots >= opt2.lots ? {w, d, ...opt1} : {w:d, d:w, ...opt2};

      // Outer parcel outline (glowing)
      const outlineGeom = new THREE.BoxGeometry(best.w, 50, best.d);
      const outlineMat = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.9});
      const outline = new THREE.Mesh(outlineGeom, outlineMat);
      const edges = new THREE.EdgesGeometry(outlineGeom);
      const lineMat = new THREE.LineBasicMaterial({color:0x000000, linewidth:6});
      const wire = new THREE.LineSegments(edges, lineMat);
      parcelGroup.add(outline, wire);

      // Subdivide
      let x = -best.w/2;
      while (x < best.w/2) {
        const remainingWidth = best.w/2 - x;
        const lotWidth = rule.width && remainingWidth >= rule.width 
          ? Math.min(remainingWidth, Math.max(rule.width, rule.area / best.d))
          : remainingWidth;
        if (lotWidth * best.d < rule.area * 0.9) break;

        const lotGeom = new THREE.BoxGeometry(lotWidth, 52, best.d);
        const lotMat = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.04});
        const lot = new THREE.Mesh(lotGeom, lotMat);
        lot.position.x = x + lotWidth/2;
        lot.position.y = 1;
        parcelGroup.add(lot);

        const lotEdges = new THREE.EdgesGeometry(lotGeom);
        const lotLine = new THREE.LineSegments(lotEdges, new THREE.LineBasicMaterial({color:0x000000, linewidth:3}));
        lotLine.position.copy(lot.position);
        parcelGroup.add(lotLine);

        x += lotWidth;
      }

      const acres = (best.w * best.d / 43560).toFixed(2);
      const lots = best.lots;
      document.getElementById('info').textContent = `${lots} LOTS • ${acres} ACRES TOTAL`;

      // Gentle breathing animation
      parcelGroup.position.y = -200;
      new TWEEN.Tween(parcelGroup.position)
        .to({y:0}, 1800)
        .easing(TWEEN.Easing.Elastic.Out)
        .start();
    }

    function calculateLots(width, depth, rule) {
      let lots = 0;
      let x = 0;
      while (x < width) {
        const remaining = width - x;
        const minW = rule.width ? rule.width : rule.area / depth;
        if (remaining < minW) break;
        const lotW = Math.max(minW, rule.area / depth);
        if (lotW * depth < rule.area * 0.9) break;
        x += lotW;
        lots++;
      }
      return {lots};
    }

    function reset() {
      document.getElementById('scene').innerHTML = '';
      document.getElementById('scene').classList.remove('active');
      document.getElementById('input-card').style.display = 'block';
      setTimeout(() => {
        document.getElementById('input-card').style.opacity = '1';
        document.getElementById('input-card').style.transform = 'translate(-50%,-50%) scale(1)';
      }, 50);
      document.getElementById('info').textContent = '';
    }

    // TWEEN for elastic entrance
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/tween.js@18.6.4/dist/tween.umd.js';
    document.head.appendChild(script);
  </script>
</body>
</html>
